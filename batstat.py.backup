#!/usr/bin/env python3
"""
Battery Status Script - batstat
A beautiful battery status display for macOS using ioreg
Refactored from fish shell to Python for better maintainability and functionality
"""

import subprocess
import re
import sys
from datetime import datetime
from typing import Dict, Optional, Tuple


class Colors:
    """ANSI color codes for terminal output"""
    RESET = '\033[0m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    ORANGE = '\033[38;5;208m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    GRAY = '\033[38;5;246m'


class BatteryData:
    """Container for battery information"""

    def __init__(self, ioreg_output: str):
        self.data = self._parse_ioreg(ioreg_output)

    def _parse_ioreg(self, output: str) -> Dict[str, str]:
        """Parse ioreg output and extract battery metrics"""
        data = {}

        # Define patterns for each metric
        patterns = {
            'current_capacity': r'"CurrentCapacity" = (\d+)',
            'max_capacity': r'"MaxCapacity" = (\d+)',
            'design_capacity': r'"DesignCapacity" = (\d+)',
            'cycle_count': r'"CycleCount" = (\d+)',
            'temperature': r'"Temperature" = (\d+)',
            'voltage': r'"Voltage" = (\d+)',
            'amperage': r'"Amperage" = (-?\d+)',
            'is_charging': r'"IsCharging" = (\w+)',
            'external_connected': r'"ExternalConnected" = (\w+)',
            'fully_charged': r'"FullyCharged" = (\w+)',
            'time_remaining': r'"TimeRemaining" = (-?\d+)',
            'serial': r'"Serial" = "([A-Za-z0-9]*)"',
            'adapter_name': r'"Name" = "([A-Za-z0-9 -]*)"',
            'adapter_watts': r'"Watts" = (\d+)',
        }

        for key, pattern in patterns.items():
            match = re.search(pattern, output)
            data[key] = match.group(1) if match else None

        return data

    def get_int(self, key: str, default: int = 0) -> int:
        """Get integer value from data"""
        value = self.data.get(key)
        return int(value) if value and value.isdigit() else default

    def get_float(self, key: str, default: float = 0.0) -> float:
        """Get float value from data"""
        value = self.data.get(key)
        return float(value) if value else default

    def get_str(self, key: str, default: str = "") -> str:
        """Get string value from data"""
        return self.data.get(key) or default


def get_battery_data() -> Optional[BatteryData]:
    """Get battery data from ioreg"""
    try:
        result = subprocess.run(
            ['ioreg', '-lrn', 'AppleSmartBattery'],
            capture_output=True,
            text=True,
            check=True
        )
        return BatteryData(result.stdout)
    except (subprocess.CalledProcessError, FileNotFoundError):
        return None


def calculate_battery_percentage(battery: BatteryData) -> float:
    """Calculate battery percentage"""
    current = battery.get_int('current_capacity')
    max_cap = battery.get_int('max_capacity')

    if max_cap == 0:
        return 0.0
    return round(current * 100.0 / max_cap, 1)


def calculate_health_percentage(battery: BatteryData) -> float:
    """Calculate battery health percentage"""
    max_cap = battery.get_int('max_capacity')
    design_cap = battery.get_int('design_capacity')

    if design_cap == 0:
        return 0.0
    return round(max_cap * 100.0 / design_cap, 1)


def get_battery_status(battery: BatteryData) -> Tuple[str, str]:
    """Determine battery status and icon"""
    is_charging = battery.get_str('is_charging') == "Yes"
    external_connected = battery.get_str('external_connected') == "Yes"
    fully_charged = battery.get_str('fully_charged') == "Yes"

    if is_charging:
        return "‚ö°", "Charging"
    elif external_connected and fully_charged:
        return "üîå", "Fully Charged"
    elif external_connected:
        return "üîå", "Not Charging"
    else:
        return "üîã", "Discharging"


def format_time_remaining(battery: BatteryData) -> str:
    """Format time remaining string"""
    time_remaining = battery.get_int('time_remaining')
    is_charging = battery.get_str('is_charging') == "Yes"

    if time_remaining in (65535, -1, 0) or time_remaining == 0:
        return "Calculating..." if not is_charging else "Almost full"

    if time_remaining > 0:
        hours = time_remaining // 60
        minutes = time_remaining % 60
        return f"{hours}h {minutes}m"

    return "Almost full"


def get_battery_color(percentage: float) -> str:
    """Get color based on battery percentage"""
    if percentage <= 20:
        return Colors.RED
    elif percentage <= 40:
        return Colors.ORANGE
    elif percentage <= 60:
        return Colors.YELLOW
    else:
        return Colors.GREEN


def get_health_color(health_percentage: float) -> str:
    """Get color based on battery health"""
    if health_percentage <= 60:
        return Colors.RED
    elif health_percentage <= 80:
        return Colors.YELLOW
    else:
        return Colors.GREEN


def create_progress_bar(percentage: float, length: int = 44) -> str:
    """Create a progress bar"""
    filled_length = int(percentage * length / 100)
    empty_length = length - filled_length

    return "‚ñà" * filled_length + "‚ñë" * empty_length


def center_text(text: str, width: int) -> str:
    """Center text within given width"""
    text_len = len(text)
    if text_len >= width:
        return text[:width]

    padding = width - text_len
    left_pad = padding // 2
    right_pad = padding - left_pad

    return " " * left_pad + text + " " * right_pad


def create_header_line(title: str, width: int) -> str:
    """Create a header line with title"""
    base = f"‚îÄ {title} "
    base_len = len(base)

    if base_len >= width:
        return base[:width]

    filler_len = width - base_len
    return base + "‚îÄ" * filler_len


def format_current_draw(amperage: int) -> Tuple[str, str]:
    """Format current draw information"""
    if amperage == 0:
        return "0mA (idle)", Colors.GRAY
    elif amperage > 0:
        return f"+{amperage}mA (charging)", Colors.GREEN
    else:
        return f"{abs(amperage)}mA (drawing)", Colors.ORANGE


def truncate_text(text: str, max_length: int) -> str:
    """Truncate text to maximum length"""
    if len(text) <= max_length:
        return text
    return text[:max_length - 3] + "..."


def display_battery_status():
    """Main function to display battery status"""
    battery = get_battery_data()
    if not battery:
        print(f"{Colors.RED}‚ùå Unable to read battery information{Colors.RESET}")
        sys.exit(1)

    # Calculate values
    percentage = calculate_battery_percentage(battery)
    health_percentage = calculate_health_percentage(battery)
    status_icon, status_text = get_battery_status(battery)
    time_str = format_time_remaining(battery)

    # Temperature calculations
    temp_celsius = battery.get_float('temperature') / 100.0
    temp_fahrenheit = temp_celsius * 9.0 / 5.0 + 32.0

    # Voltage calculation
    voltage_volts = battery.get_float('voltage') / 1000.0

    # Get colors
    battery_color = get_battery_color(percentage)
    health_color = get_health_color(health_percentage)

    # Layout constants
    inner_width = 44
    blank_inner = " " * inner_width
    solid_line = "‚îÄ" * inner_width

    # Display header
    print()
    header_title = center_text(f"{Colors.PURPLE}üîã BATTERY STATUS üîã{Colors.CYAN}", inner_width)
    print(f"{Colors.CYAN}‚ï≠{solid_line}‚ïÆ{Colors.RESET}")
    print(f"{Colors.CYAN}‚îÇ{header_title}‚îÇ{Colors.RESET}")
    print(f"{Colors.CYAN}‚ï∞{solid_line}‚ïØ{Colors.RESET}")
    print()

    # Battery Level Section
    battery_header = create_header_line("Battery Level", inner_width)
    print(f"{Colors.GRAY}‚îå{battery_header}‚îê{Colors.RESET}")

    # Status line
    status_label = " Status:    "
    status_value = f"{status_text:<10} {percentage:>3.0f}% {status_icon:>3s}"
    status_line = f"{status_label}{battery_color}{status_value}{Colors.GRAY}"
    status_line += " " * (inner_width - len(status_label + status_value))
    print(f"{Colors.GRAY}‚îÇ{status_line}‚îÇ{Colors.RESET}")

    # Empty line
    print(f"{Colors.GRAY}‚îÇ{blank_inner}‚îÇ{Colors.RESET}")

    # Progress bar
    progress_bar = create_progress_bar(percentage, inner_width)
    print(f"{Colors.GRAY}‚îÇ{battery_color}{progress_bar}{Colors.GRAY}‚îÇ{Colors.RESET}")
    print(f"{Colors.GRAY}‚îî{solid_line}‚îò{Colors.RESET}")
    print()

    # Battery Health Section
    health_header = create_header_line("Battery Health", inner_width)
    print(f"{Colors.CYAN}‚îå{health_header}‚îê{Colors.RESET}")

    # Health line
    health_label = " Health:    "
    max_cap = battery.get_int('max_capacity')
    design_cap = battery.get_int('design_capacity')
    health_value = f"{health_percentage:>3.0f}% ({max_cap} / {design_cap} mAh)"
    health_line = f"{health_label}{health_color}{health_value}{Colors.GRAY}"
    health_line += " " * (inner_width - len(health_label + health_value))
    print(f"{Colors.GRAY}‚îÇ{health_line}‚îÇ{Colors.RESET}")

    # Cycles line
    cycles_label = " Cycles:    "
    cycles = battery.get_int('cycle_count')
    cycles_value = str(cycles)
    cycles_line = f"{cycles_label}{Colors.BLUE}{cycles_value}{Colors.GRAY}"
    cycles_line += " " * (inner_width - len(cycles_label + cycles_value))
    print(f"{Colors.GRAY}‚îÇ{cycles_line}‚îÇ{Colors.RESET}")

    print(f"{Colors.GRAY}‚îî{solid_line}‚îò{Colors.RESET}")
    print()

    # Power Details Section
    power_header = create_header_line("Power Details", inner_width)
    print(f"{Colors.PURPLE}‚îå{power_header}‚îê{Colors.RESET}")

    # Voltage line
    voltage_label = " Voltage:   "
    voltage_value = f"{voltage_volts:>6.2f}V"
    voltage_line = f"{voltage_label}{Colors.YELLOW}{voltage_value}{Colors.GRAY}"
    voltage_line += " " * (inner_width - len(voltage_label + voltage_value))
    print(f"{Colors.GRAY}‚îÇ{voltage_line}‚îÇ{Colors.RESET}")

    # Current line
    current_label = " Current:   "
    amperage = battery.get_int('amperage')
    current_text, current_color = format_current_draw(amperage)
    current_line = f"{current_label}{current_color}{current_text}{Colors.GRAY}"
    current_line += " " * (inner_width - len(current_label + current_text))
    print(f"{Colors.GRAY}‚îÇ{current_line}‚îÇ{Colors.RESET}")

    # Temperature line
    temp_label = " Temp:      "
    temp_value_full = f"{temp_celsius:.1f}¬∞C / {temp_fahrenheit:.1f}¬∞F"
    temp_line = f"{temp_label}{Colors.CYAN}{temp_celsius:.1f}¬∞C{Colors.GRAY} / {temp_fahrenheit:.1f}¬∞F"
    temp_line += " " * (inner_width - len(temp_label + temp_value_full))
    print(f"{Colors.GRAY}‚îÇ{temp_line}‚îÇ{Colors.RESET}")

    print(f"{Colors.GRAY}‚îî{solid_line}‚îò{Colors.RESET}")
    print()

    # Time Remaining Section (only if valid time)
    if time_str not in ("Calculating...", "Almost full"):
        time_header = create_header_line("Time Remaining", inner_width)
        print(f"{Colors.GREEN}‚îå{time_header}‚îê{Colors.RESET}")

        time_content = f" {time_str}"
        time_line = f"{time_content}{Colors.GREEN}{time_str}{Colors.GRAY}"
        time_line += " " * (inner_width - len(time_content))
        time_line = time_line.replace(time_str, f"{Colors.GREEN}{time_str}{Colors.GRAY}")
        print(f"{Colors.GRAY}‚îÇ{' ' + time_str.ljust(inner_width - 1)}‚îÇ{Colors.RESET}")
        print(f"{Colors.GRAY}‚îî{solid_line}‚îò{Colors.RESET}")
        print()

    # Power Adapter Section (if connected)
    external_connected = battery.get_str('external_connected') == "Yes"
    adapter_name = battery.get_str('adapter_name')

    if external_connected and adapter_name:
        adapter_header = create_header_line("Power Adapter", inner_width)
        print(f"{Colors.BLUE}‚îå{adapter_header}‚îê{Colors.RESET}")

        # Adapter type
        adapter_label = " Type:      "
        adapter_display = truncate_text(adapter_name, inner_width - len(adapter_label))
        adapter_line = f"{adapter_label}{Colors.BLUE}{adapter_display}{Colors.GRAY}"
        adapter_line += " " * (inner_width - len(adapter_label + adapter_display))
        print(f"{Colors.GRAY}‚îÇ{adapter_line}‚îÇ{Colors.RESET}")

        # Adapter watts (if available)
        adapter_watts = battery.get_int('adapter_watts')
        if adapter_watts > 0:
            watts_label = " Power:     "
            watts_value = f"{adapter_watts}W"
            watts_line = f"{watts_label}{Colors.YELLOW}{watts_value}{Colors.GRAY}"
            watts_line += " " * (inner_width - len(watts_label + watts_value))
            print(f"{Colors.GRAY}‚îÇ{watts_line}‚îÇ{Colors.RESET}")

        print(f"{Colors.GRAY}‚îî{solid_line}‚îò{Colors.RESET}")
        print()

    # System Info Section
    system_header = create_header_line("System Info", inner_width)
    print(f"{Colors.GRAY}‚îå{system_header}‚îê{Colors.RESET}")

    # Serial number
    serial_label = " Serial:    "
    serial = battery.get_str('serial')
    serial_display = truncate_text(serial, inner_width - len(serial_label))
    serial_line = f"{serial_label}{Colors.GRAY}{serial_display}{Colors.GRAY}"
    serial_line += " " * (inner_width - len(serial_label + serial_display))
    print(f"{Colors.GRAY}‚îÇ{serial_line}‚îÇ{Colors.RESET}")

    # Last updated
    updated_label = " Updated:   "
    updated_at = datetime.now().strftime("%H:%M:%S")
    updated_line = f"{updated_label}{Colors.GRAY}{updated_at}{Colors.GRAY}"
    updated_line += " " * (inner_width - len(updated_label + updated_at))
    print(f"{Colors.GRAY}‚îÇ{updated_line}‚îÇ{Colors.RESET}")

    print(f"{Colors.GRAY}‚îî{solid_line}‚îò{Colors.RESET}")
    print()


if __name__ == "__main__":
    display_battery_status()